\section{Related Work}

\rev{ We classify the existing representative packet classification algorithms into three categories: The first category is the tuple-based methods that support dynamic updates, containing the classic tuple-based method, the merged tuple method and the binary search tree method. The second category is the decision tree methods that only focus on high lookup speed, but are hard to updates. The third category is the the hardware methods that use additional hardware to support lookup. Our proposed DTC falls into the first category because of the high update speed, and has the same high lookup speed as the state-of-art decision tree method in the second category.}

\textbf{The classic tuple-based method:} The classic tuple-based method is Tuple Space Search (TSS) \cite{srinivasan1999packet}. It divides rules into multiple tuples according to the prefix lengths of two fields, the source IP address and the destination IP address. A 32 bit address can form up to 33*33 tuples. Each tuple contains a cuckoo hash table and uses the chain structure to store the rules with \rev{all the five fields}. \note{For the same prefix, it can have a few rules. Why not including IP address?} The update operation in TSS \rev{is mapped to a specific tuple}, \note{what do you mean "occurs in the corresponding tuple"? How to find a tuple for the update?} which leads to fast update speed. However, TSS has a slow lookup speed, because it rev{requires traversing} each tuple and to look for the rule with the highest priority.

\textbf{The merged tuple method:} TupleMerge \cite{daly2017tuplemerge} improves upon TSS by omitting bits of the rule. The mask length of a tuple is decided by the first inserted rule, and it can store the rules with a longer mask length until the rule chain is longer than a threshold $k$. If a rule can not be inserted into any current tuple, it will build a new tuple. In this way, TupleMerge reduces the number of tuples to improve its lookup speed. However, its lookup speed is slower than SmartSplit, and its update operation rev{requires traversing} the tuples rather than being mapped directly to a specific tuple, so its update speed is slower than TSS.


\textbf{The binary search tree method:} PartitionSort \cite{yingchareonthawornchai2016sorted} classifies a packet based on binary search tree. It splits the rules into multiple tuples, each containing sortable rules. The orders of the five fields in these tuples can be different. The data structure in each tuple is optimized by a binary search tree, and the complexity of the lookup and update operation is \rev{ the logarithm of the rules}. \note{what is d and n? Explain}  Most rules can be stored in the first few tuples. As a result, PartitionSort achieves fast lookup speed and fast update speed. However, its lookup speed is slower than SmartSplit, and its update speed is slower than TSS.
%These performances still need to be improved.


\textbf{The decision tree methods:} Some decision tree methods such as HiCuts \cite{gupta1999packet}, HyperCuts \cite{george2003packet}, HyperSplit \cite{qi2009packet}, Efficuts \cite{vamanan2011efficuts}, SmartSplit \cite{he2014meta}, BitCuts \cite{liu2015bitcuts}, CutSplit \cite{li2018cutsplit} and ByteCuts \cite{daly2018bytecuts} use one or more decision trees to build data structure. Each node in the decision tree represents a range of five fields and stores the rules that overlap with the node ranges. The node splits the range into multiple intervals to form children nodes and allocates rules to the children nodes. The rule that overlaps with multiple nodes will be copied multiple times. This could lead to the explosion of memory consumption in decision tree methods. \rev {The state-of-art decision tree method, ByteCuts, uses byte extraction to cut the rules, which achieves the highest lookup speed and small memory cost. However, the splitting scheme of these methods depends on the rule set at the building time.} If the rules are constantly updated, the previous splitting scheme could be inappropriate, which can further affect the lookup speed and the memory cost. Therefore, these decision tree methods are not suitable for high speed updates.\note{(ZCY) I simplify this part and add ByteCuts.}





%Therefore, the performance of TupleMerge is still limited.

\textbf{The hardware methods:} Ternary content addressable memory (TCAM) is a hardware device. It is mainly used to quickly find ACLs, routes and other entries. TCAM has been used for packet classification \cite{lakshminarayanan2005algorithms, pao2006efficient, bremler2010space, che2008dres, liu2010tcam, ma2012smart} to improve the lookup speed, but it has small memory size and can not store a large number of rules. In addition, TCAM cannot well support the dynamic updates. Some FPGA methods \cite{fong2012parasplit, chang2018fast} and GPU methods \cite{varvello2016multilayer, chiu2018design} have the same problems. Finally, hardware methods add the costs of hardware and energy. Therefore, these algorithms are difficult to apply to the SDN environment where the rules may need to be flexibly updated.